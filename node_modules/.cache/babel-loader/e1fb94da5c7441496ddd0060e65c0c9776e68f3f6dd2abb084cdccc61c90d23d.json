{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport React from 'react';\nimport normalizeWheel from 'normalize-wheel';\n\n/**\r\n * Compute the dimension of the crop area based on media size,\r\n * aspect ratio and optionally rotation\r\n */\n\nfunction getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaWidth, mediaHeight, rotation),\n    width = _a.width,\n    height = _a.height;\n  var fittingWidth = Math.min(width, containerWidth);\n  var fittingHeight = Math.min(height, containerHeight);\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight\n    };\n  }\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect\n  };\n}\n/**\r\n * Compute media zoom.\r\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\r\n */\n\nfunction getMediaZoom(mediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;\n}\n/**\r\n * Ensure a new media position stays in the crop area.\r\n */\n\nfunction restrictPosition(position, mediaSize, cropSize, zoom, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),\n    width = _a.width,\n    height = _a.height;\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\nfunction restrictPositionCoord(position, mediaSize, cropSize, zoom) {\n  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;\n  return clamp(position, -maxPosition, maxPosition);\n}\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\r\n * Compute the output cropped area of the media in percentages and pixels.\r\n * x/y are the top-left coordinates on the src media\r\n */\n\nfunction computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  if (restrictPosition === void 0) {\n    restrictPosition = true;\n  } // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n\n  var limitAreaFn = restrictPosition ? limitArea : noOp;\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation); // calculate the crop area in percentages\n  // in the rotated space\n\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),\n    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)\n  }; // we compute the pixels size naively\n\n  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));\n  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));\n  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect; // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n  var croppedAreaPixels = __assign(__assign({}, sizePixels), {\n    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),\n    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))\n  });\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\r\n * Ensure the returned value is between 0 and max\r\n */\n\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\nfunction noOp(_max, value) {\n  return value;\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPercentages.\r\n */\n\nfunction getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation); // This is the inverse process of computeCroppedArea\n\n  var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);\n  var crop = {\n    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Compute zoom from the croppedAreaPixels\r\n */\n\nfunction getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = getMediaZoom(mediaSize);\n  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPixels\r\n */\n\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);\n  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;\n  var crop = {\n    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Return the point that is the center of point a and b\r\n */\n\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\n\nfunction rotateSize(width, height, rotation) {\n  var rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n/**\r\n * Clamp value between min and max\r\n */\n\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Combine multiple class names into a single string.\r\n */\n\nfunction classNames() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  return args.filter(function (value) {\n    if (typeof value === 'string' && value.length > 0) {\n      return true;\n    }\n    return false;\n  }).join(' ').trim();\n}\nvar css_248z = \".reactEasyCrop_Container {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  overflow: hidden;\\n  user-select: none;\\n  touch-action: none;\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.reactEasyCrop_Image,\\n.reactEasyCrop_Video {\\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\\n}\\n\\n.reactEasyCrop_Contain {\\n  max-width: 100%;\\n  max-height: 100%;\\n  margin: auto;\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n}\\n.reactEasyCrop_Cover_Horizontal {\\n  width: 100%;\\n  height: auto;\\n}\\n.reactEasyCrop_Cover_Vertical {\\n  width: auto;\\n  height: 100%;\\n}\\n\\n.reactEasyCrop_CropArea {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  box-sizing: border-box;\\n  box-shadow: 0 0 0 9999em;\\n  color: rgba(0, 0, 0, 0.5);\\n  overflow: hidden;\\n}\\n\\n.reactEasyCrop_CropAreaRound {\\n  border-radius: 50%;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::before {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 0;\\n  bottom: 0;\\n  left: 33.33%;\\n  right: 33.33%;\\n  border-top: 0;\\n  border-bottom: 0;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::after {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 33.33%;\\n  bottom: 33.33%;\\n  left: 0;\\n  right: 0;\\n  border-left: 0;\\n  border-right: 0;\\n}\\n\";\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\nvar Cropper = /** @class */\nfunction (_super) {\n  __extends(Cropper, _super);\n  function Cropper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.imageRef = /*#__PURE__*/React.createRef();\n    _this.videoRef = /*#__PURE__*/React.createRef();\n    _this.containerRef = null;\n    _this.styleRef = null;\n    _this.containerRect = null;\n    _this.mediaSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.gestureZoomStart = 0;\n    _this.gestureRotationStart = 0;\n    _this.isTouching = false;\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.wheelTimer = null;\n    _this.currentDoc = document;\n    _this.currentWindow = window;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false\n    }; // this is to prevent Safari on iOS >= 10 to zoom the page\n\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n    _this.cleanEvents = function () {\n      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);\n      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);\n      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);\n      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);\n    };\n    _this.clearScrollEvent = function () {\n      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n    };\n    _this.onMediaLoad = function () {\n      var cropSize = _this.computeSizes();\n      if (cropSize) {\n        _this.emitCropData();\n        _this.setInitialCrop(cropSize);\n      }\n      if (_this.props.onMediaLoaded) {\n        _this.props.onMediaLoaded(_this.mediaSize);\n      }\n    };\n    _this.setInitialCrop = function (cropSize) {\n      if (_this.props.initialCroppedAreaPercentages) {\n        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _a.crop,\n          zoom = _a.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      } else if (_this.props.initialCroppedAreaPixels) {\n        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n          crop = _b.crop,\n          zoom = _b.zoom;\n        _this.props.onCropChange(crop);\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      }\n    };\n    _this.computeSizes = function () {\n      var _a, _b, _c, _d, _e, _f;\n      var mediaRef = _this.imageRef.current || _this.videoRef.current;\n      if (mediaRef && _this.containerRef) {\n        _this.containerRect = _this.containerRef.getBoundingClientRect();\n        var containerAspect = _this.containerRect.width / _this.containerRect.height;\n        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;\n        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;\n        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;\n        var mediaAspect = naturalWidth / naturalHeight; // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n        // as the values they report are rounded. That will result in precision losses\n        // when calculating zoom. We use the fact that the media is positionned relative\n        // to the container. That allows us to use the container's dimensions\n        // and natural aspect ratio of the media to calculate accurate media size.\n        // However, for this to work, the container should not be rotated\n\n        var renderedMediaSize = void 0;\n        if (isMediaScaledDown) {\n          switch (_this.props.objectFit) {\n            default:\n            case 'contain':\n              renderedMediaSize = containerAspect > mediaAspect ? {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              } : {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'horizontal-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n            case 'vertical-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n            case 'auto-cover':\n              renderedMediaSize = naturalWidth > naturalHeight ? {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              } : {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n          }\n        } else {\n          renderedMediaSize = {\n            width: mediaRef.offsetWidth,\n            height: mediaRef.offsetHeight\n          };\n        }\n        _this.mediaSize = __assign(__assign({}, renderedMediaSize), {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight\n        }); // set media size in the parent\n\n        if (_this.props.setMediaSize) {\n          _this.props.setMediaSize(_this.mediaSize);\n        }\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);\n        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {\n          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);\n        }\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition); // pass crop size to parent\n\n        if (_this.props.setCropSize) {\n          _this.props.setCropSize(cropSize);\n        }\n        return cropSize;\n      }\n    };\n    _this.onMouseDown = function (e) {\n      e.preventDefault();\n      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);\n      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n    _this.onTouchStart = function (e) {\n      _this.isTouching = true;\n      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {\n        return;\n      }\n      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n\n      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n    _this.onGestureStart = function (e) {\n      e.preventDefault();\n      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);\n      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);\n      _this.gestureZoomStart = _this.props.zoom;\n      _this.gestureRotationStart = _this.props.rotation;\n    };\n    _this.onGestureMove = function (e) {\n      e.preventDefault();\n      if (_this.isTouching) {\n        // this is to avoid conflict between gesture and touch events\n        return;\n      }\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.gestureZoomStart - 1 + e.scale;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (_this.props.onRotationChange) {\n        var newRotation = _this.gestureRotationStart + e.rotation;\n        _this.props.onRotationChange(newRotation);\n      }\n    };\n    _this.onGestureEnd = function (e) {\n      _this.cleanEvents();\n    };\n    _this.onDragStart = function (_a) {\n      var _b, _c;\n      var x = _a.x,\n        y = _a.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = __assign({}, _this.props.crop);\n      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n    _this.onDrag = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {\n        if (!_this.state.cropSize) return;\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      });\n    };\n    _this.onDragStopped = function () {\n      var _a, _b;\n      _this.isTouching = false;\n      _this.cleanEvents();\n      _this.emitCropData();\n      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    _this.onWheel = function (e) {\n      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {\n        return;\n      }\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var pixelY = normalizeWheel(e).pixelY;\n      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;\n      _this.setNewZoom(newZoom, point, {\n        shouldUpdatePosition: true\n      });\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n      _this.wheelTimer = _this.currentWindow.setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          var _a, _b;\n          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }, 250);\n    };\n    _this.getPointOnContainer = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    };\n    _this.getPointOnMedia = function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      var _b = _this.props,\n        crop = _b.crop,\n        zoom = _b.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n    _this.setNewZoom = function (zoom, point, _a) {\n      var _b = (_a === void 0 ? {} : _a).shouldUpdatePosition,\n        shouldUpdatePosition = _b === void 0 ? true : _b;\n      if (!_this.state.cropSize || !_this.props.onZoomChange) return;\n      var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);\n      if (shouldUpdatePosition) {\n        var zoomPoint = _this.getPointOnContainer(point);\n        var zoomTarget = _this.getPointOnMedia(zoomPoint);\n        var requestedPosition = {\n          x: zoomTarget.x * newZoom - zoomPoint.x,\n          y: zoomTarget.y * newZoom - zoomPoint.y\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n        _this.props.onCropChange(newPosition);\n      }\n      _this.props.onZoomChange(newZoom);\n    };\n    _this.getCropData = function () {\n      if (!_this.state.cropSize) {\n        return null;\n      } // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n\n      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);\n    };\n    _this.emitCropData = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropComplete) {\n        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n      }\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.emitCropAreaChange = function () {\n      var cropData = _this.getCropData();\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n        croppedAreaPixels = cropData.croppedAreaPixels;\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n    _this.recomputeCropPosition = function () {\n      if (!_this.state.cropSize) return;\n      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      _this.props.onCropChange(newPosition);\n      _this.emitCropData();\n    };\n    return _this;\n  }\n  Cropper.prototype.componentDidMount = function () {\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument;\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView;\n      }\n      this.currentWindow.addEventListener('resize', this.computeSizes);\n      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart);\n    }\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style');\n      this.styleRef.setAttribute('type', 'text/css');\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce);\n      }\n      this.styleRef.innerHTML = css_248z;\n      this.currentDoc.head.appendChild(this.styleRef);\n    } // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad();\n    } // set image and video refs in the parent if the callbacks exist\n\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef);\n    }\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef);\n    }\n  };\n  Cropper.prototype.componentWillUnmount = function () {\n    var _a;\n    this.currentWindow.removeEventListener('resize', this.computeSizes);\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);\n    }\n    if (this.styleRef) {\n      (_a = this.styleRef.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.styleRef);\n    }\n    this.cleanEvents();\n    this.props.zoomWithScroll && this.clearScrollEvent();\n  };\n  Cropper.prototype.componentDidUpdate = function (prevProps) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes();\n      this.recomputeCropPosition();\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes();\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition();\n    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {\n      this.computeSizes();\n    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {\n      this.emitCropAreaChange();\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      }) : this.clearScrollEvent();\n    }\n    if (prevProps.video !== this.props.video) {\n      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();\n    }\n  };\n  Cropper.prototype.getAspect = function () {\n    var _a = this.props,\n      cropSize = _a.cropSize,\n      aspect = _a.aspect;\n    if (cropSize) {\n      return cropSize.width / cropSize.height;\n    }\n    return aspect;\n  };\n  Cropper.prototype.onPinchStart = function (e) {\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);\n    this.onDragStart(getCenter(pointA, pointB));\n  };\n  Cropper.prototype.onPinchMove = function (e) {\n    var _this = this;\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    var center = getCenter(pointA, pointB);\n    this.onDrag(center);\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {\n      var distance = getDistanceBetweenPoints(pointA, pointB);\n      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);\n      _this.setNewZoom(newZoom, center, {\n        shouldUpdatePosition: false\n      });\n      _this.lastPinchDistance = distance;\n      var rotation = getRotationBetweenPoints(pointA, pointB);\n      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);\n      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);\n      _this.lastPinchRotation = rotation;\n    });\n  };\n  Cropper.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      image = _a.image,\n      video = _a.video,\n      mediaProps = _a.mediaProps,\n      transform = _a.transform,\n      _b = _a.crop,\n      x = _b.x,\n      y = _b.y,\n      rotation = _a.rotation,\n      zoom = _a.zoom,\n      cropShape = _a.cropShape,\n      showGrid = _a.showGrid,\n      _c = _a.style,\n      containerStyle = _c.containerStyle,\n      cropAreaStyle = _c.cropAreaStyle,\n      mediaStyle = _c.mediaStyle,\n      _d = _a.classes,\n      containerClassName = _d.containerClassName,\n      cropAreaClassName = _d.cropAreaClassName,\n      mediaClassName = _d.mediaClassName,\n      objectFit = _a.objectFit;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      ref: function ref(el) {\n        return _this.containerRef = el;\n      },\n      \"data-testid\": \"container\",\n      style: containerStyle,\n      className: classNames('reactEasyCrop_Container', containerClassName)\n    }, image ? /*#__PURE__*/React.createElement(\"img\", __assign({\n      alt: \"\",\n      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      src: image,\n      ref: this.imageRef,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      onLoad: this.onMediaLoad\n    })) : video && /*#__PURE__*/React.createElement(\"video\", __assign({\n      autoPlay: true,\n      loop: true,\n      muted: true,\n      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      ref: this.videoRef,\n      onLoadedMetadata: this.onMediaLoad,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      controls: false\n    }), (Array.isArray(video) ? video : [{\n      src: video\n    }]).map(function (item) {\n      return /*#__PURE__*/React.createElement(\"source\", __assign({\n        key: item.src\n      }, item));\n    })), this.state.cropSize && /*#__PURE__*/React.createElement(\"div\", {\n      style: __assign(__assign({}, cropAreaStyle), {\n        width: this.state.cropSize.width,\n        height: this.state.cropSize.height\n      }),\n      \"data-testid\": \"cropper\",\n      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)\n    }));\n  };\n  Cropper.defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    objectFit: 'contain',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true\n  };\n  Cropper.getMousePoint = function (e) {\n    return {\n      x: Number(e.clientX),\n      y: Number(e.clientY)\n    };\n  };\n  Cropper.getTouchPoint = function (touch) {\n    return {\n      x: Number(touch.clientX),\n      y: Number(touch.clientY)\n    };\n  };\n  return Cropper;\n}(React.Component);\nexport default Cropper;\nexport { getInitialCropFromCroppedAreaPercentages, getInitialCropFromCroppedAreaPixels };","map":{"version":3,"mappings":"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","names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","rotation","rotateSize","width","height","fittingWidth","Math","min","fittingHeight","getMediaZoom","mediaSize","naturalWidth","naturalHeight","restrictPosition","position","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","clamp","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","computeCroppedArea","crop","limitAreaFn","limitArea","noOp","mediaBBoxSize","mediaNaturalBBoxSize","croppedAreaPercentages","widthInPixels","round","heightInPixels","isImgWiderThanHigh","sizePixels","croppedAreaPixels","max","value","_max","getInitialCropFromCroppedAreaPercentages","minZoom","maxZoom","getZoomFromCroppedAreaPixels","mediaZoom","getInitialCropFromCroppedAreaPixels","cropZoom","getCenter","a","b","getRadianAngle","degreeValue","rotRad","abs","cos","sin","classNames","args","filter","length","join","trim","MIN_ZOOM","MAX_ZOOM","__extends","_this","React","createRef","document","window","hasWheelJustStarted","e","preventDefault","currentDoc","removeEventListener","onMouseMove","onDragStopped","onTouchMove","onGestureMove","onGestureEnd","containerRef","onWheel","wheelTimer","clearTimeout","computeSizes","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPercentages","onCropChange","onZoomChange","initialCroppedAreaPixels","mediaRef","imageRef","current","videoRef","containerRect","getBoundingClientRect","containerAspect","videoWidth","videoHeight","isMediaScaledDown","offsetWidth","offsetHeight","mediaAspect","renderedMediaSize","objectFit","setMediaSize","state","onCropSizeChange","setState","recomputeCropPosition","setCropSize","addEventListener","onDragStart","Cropper","getMousePoint","onDrag","isTouching","onTouchRequest","passive","touches","onPinchStart","getTouchPoint","onPinchMove","gestureZoomStart","gestureRotationStart","point","newZoom","scale","setNewZoom","shouldUpdatePosition","onRotationChange","newRotation","cleanEvents","_a","dragStartPosition","dragStartCrop","onInteractionStart","rafDragTimeout","currentWindow","cancelAnimationFrame","requestAnimationFrame","undefined","offsetX","offsetY","requestedPosition","newPosition","onInteractionEnd","onWheelRequest","normalizeWheel","pixelY","zoomSpeed","setTimeout","Error","left","top","_b","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","restrictedPosition","getAspect","cropData","getCropData","onCropComplete","onCropAreaChange","ownerDocument","defaultView","zoomWithScroll","onGestureStart","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","nonce","innerHTML","cssStyles","head","appendChild","complete","onMediaLoad","setImageRef","setVideoRef","preventZoomSafari","parentNode","removeChild","clearScrollEvent","prevProps","emitCropAreaChange","video","load","lastPinchDistance","lastPinchRotation","center","rafPinchTimeout","distance","image","mediaProps","transform","cropShape","showGrid","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","onMouseDown","onTouchStart","ref","el","style","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","Array","isArray","map","item","key","classes","Number","clientX","clientY","touch","Component"],"sources":["/Users/yiningmao/Desktop/DreamVideo/my-app/node_modules/src/helpers.ts","/Users/yiningmao/Desktop/DreamVideo/my-app/node_modules/src/Cropper.tsx"],"sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'horizontal-cover' | 'vertical-cover' | 'auto-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void\n  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void\n  setMediaSize?: (size: MediaSize) => void\n  setCropSize?: (size: Size) => void\n  nonce?: string\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\ntype GestureEvent = UIEvent & {\n  rotation: number\n  scale: number\n  clientX: number\n  clientY: number\n}\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: React.RefObject<HTMLImageElement> = React.createRef()\n  videoRef: React.RefObject<HTMLVideoElement> = React.createRef()\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  gestureZoomStart = 0\n  gestureRotationStart = 0\n  isTouching = false\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n  currentDoc: Document = document\n  currentWindow: Window = window\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView\n      }\n      this.currentWindow.addEventListener('resize', this.computeSizes)\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart as EventListener)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce)\n      }\n      this.styleRef.innerHTML = cssStyles\n      this.currentDoc.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad()\n    }\n\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef)\n    }\n\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef)\n    }\n  }\n\n  componentWillUnmount() {\n    this.currentWindow.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef.current?.load()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    this.currentDoc.removeEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.removeEventListener('mouseup', this.onDragStopped)\n    this.currentDoc.removeEventListener('touchmove', this.onTouchMove)\n    this.currentDoc.removeEventListener('touchend', this.onDragStopped)\n    this.currentDoc.removeEventListener('gesturemove', this.onGestureMove as EventListener)\n    this.currentDoc.removeEventListener('gestureend', this.onGestureEnd as EventListener)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef.current || this.videoRef.current\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth =\n        this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n      const naturalHeight =\n        this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.props.objectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n          case 'auto-cover':\n            renderedMediaSize =\n              naturalWidth > naturalHeight\n                ? {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n                : {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      // set media size in the parent\n      if (this.props.setMediaSize) {\n        this.props.setMediaSize(this.mediaSize)\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n      // pass crop size to parent\n      if (this.props.setCropSize) {\n        this.props.setCropSize(cropSize)\n      }\n\n      return cropSize\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent | GestureEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    this.currentDoc.addEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    this.isTouching = true\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    this.currentDoc.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    this.currentDoc.addEventListener('touchend', this.onDragStopped)\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onGestureStart = (e: GestureEvent) => {\n    e.preventDefault()\n    this.currentDoc.addEventListener('gesturechange', this.onGestureMove as EventListener)\n    this.currentDoc.addEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.gestureZoomStart = this.props.zoom\n    this.gestureRotationStart = this.props.rotation\n  }\n\n  onGestureMove = (e: GestureEvent) => {\n    e.preventDefault()\n    if (this.isTouching) {\n      // this is to avoid conflict between gesture and touch events\n      return\n    }\n\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.gestureZoomStart - 1 + e.scale\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n    if (this.props.onRotationChange) {\n      const newRotation = this.gestureRotationStart + e.rotation\n      this.props.onRotationChange(newRotation)\n    }\n  }\n\n  onGestureEnd = (e: GestureEvent) => {\n    this.cleanEvents()\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) this.currentWindow.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = this.currentWindow.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.isTouching = false\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center, { shouldUpdatePosition: false })\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = this.currentWindow.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point, { shouldUpdatePosition = true } = {}) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n\n    if (shouldUpdatePosition) {\n      const zoomPoint = this.getPointOnContainer(point)\n      const zoomTarget = this.getPointOnMedia(zoomPoint)\n      const requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            newZoom,\n            this.props.rotation\n          )\n        : requestedPosition\n\n      this.props.onCropChange(newPosition)\n    }\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n      objectFit,\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              objectFit === 'auto-cover' &&\n                (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                  ? 'reactEasyCrop_Cover_Horizontal'\n                  : 'reactEasyCrop_Cover_Vertical'),\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={this.imageRef}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                objectFit === 'auto-cover' &&\n                  (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                    ? 'reactEasyCrop_Cover_Horizontal'\n                    : 'reactEasyCrop_Cover_Vertical'),\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={this.videoRef}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}