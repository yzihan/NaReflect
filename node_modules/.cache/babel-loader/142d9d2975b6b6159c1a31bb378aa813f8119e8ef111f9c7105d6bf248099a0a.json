{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport { elementScroll } from \"./scroll.js\";\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = writingMode => {\n  switch (writingMode) {\n    case \"horizontal-tb\":\n    case \"lr\":\n    case \"lr-tb\":\n    case \"rl\":\n    case \"rl-tb\":\n      return 0 /* WritingMode.HorizontalTb */;\n    case \"vertical-rl\":\n    case \"tb\":\n    case \"tb-rl\":\n      return 1 /* WritingMode.VerticalRl */;\n    case \"vertical-lr\":\n    case \"tb-lr\":\n      return 2 /* WritingMode.VerticalLr */;\n    case \"sideways-rl\":\n      return 3 /* WritingMode.SidewaysRl */;\n    case \"sideways-lr\":\n      return 4 /* WritingMode.SidewaysLr */;\n  }\n\n  return 0 /* WritingMode.HorizontalTb */;\n};\n\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n  /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n  let layout = 0b00;\n  /**\n   * WritingMode.VerticalLr: ↓→\n   * | 1 | 4 |   |\n   * | 2 | 5 |   |\n   * | 3 |   |   |\n   *\n   * RTL: ↑→\n   * | 3 |   |   |\n   * | 2 | 5 |   |\n   * | 1 | 4 |   |\n   */\n  if (!isLTR) {\n    layout ^= 2 /* OP.ReverseVertical */;\n  }\n\n  switch (writingMode) {\n    /**\n     * ↓→\n     * | 1 | 2 | 3 |\n     * | 4 | 5 |   |\n     * |   |   |   |\n     *\n     * RTL: ↓←\n     * | 3 | 2 | 1 |\n     * |   | 5 | 4 |\n     * |   |   |   |\n     */\n    case 0 /* WritingMode.HorizontalTb */:\n      // swap horizontal and vertical\n      layout = layout >> 1 | (layout & 1) << 1;\n      [hPos, vPos] = [vPos, hPos];\n      break;\n    /**\n     * ↓←\n     * |   | 4 | 1 |\n     * |   | 5 | 2 |\n     * |   |   | 3 |\n     *\n     * RTL: ↑←\n     * |   |   | 3 |\n     * |   | 5 | 2 |\n     * |   | 4 | 1 |\n     */\n    case 1 /* WritingMode.VerticalRl */:\n    case 3 /* WritingMode.SidewaysRl */:\n      //  reverse horizontal\n      layout ^= 1 /* OP.ReverseHorizontal */;\n      break;\n    /**\n     * ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     *\n     * RTL: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     */\n    case 4 /* WritingMode.SidewaysLr */:\n      // reverse vertical\n      layout ^= 2 /* OP.ReverseVertical */;\n      break;\n  }\n  return [layout, hPos, vPos];\n};\nconst isXReversed = computedStyle => {\n  const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n  return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n  const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n  return [hPos, vPos].map((value, index) => {\n    switch (value) {\n      case \"center\":\n        return 1 /* ScrollAlignment.CenterAlways */;\n      case \"nearest\":\n        return 0 /* ScrollAlignment.ToEdgeIfNeeded */;\n      default:\n        {\n          const reverse = layout >> index & 1;\n          return value === \"start\" === !reverse ? 2 /* ScrollAlignment.LeftOrTop */ : 3 /* ScrollAlignment.RightOrBottom */;\n        }\n    }\n  });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n  if (align !== 0 /* ScrollAlignment.ToEdgeIfNeeded */) {\n    return align;\n  }\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓\n   *          │  │\n   *        ┃ │  │ ┃        do nothing\n   *          │  │\n   *        ┗━│━━│━┛\n   *          └──┘\n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *    ┏ ━ ━ ━ ━ ┓\n   *   ┌───────────┐\n   *   │┃         ┃│        do nothing\n   *   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛\n   */\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return null;\n  }\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓         ┏━┌━━┐━┓\n   *          └──┘             │  │\n   *  from  ┃      ┃     to  ┃ └──┘ ┃\n   *\n   *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n   *                           │  │\n   *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n   *          │  │             │  │\n   *        ┗━│━━│━┛         ┗━│━━│━┛\n   *          │  │             └──┘\n   *          │  │\n   *          └──┘\n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───┐                 ┌───┐\n   *  │ ┃ │       ┃         ┃   │     ┃\n   *  └───┘                 └───┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *        ┌───────────┐   ┌───────────┐\n   *    ┃   │     ┃     │   ┃         ┃ │\n   *        └───────────┘   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   */\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return 2 /* ScrollAlignment.LeftOrTop */;\n  }\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n   *\n   *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n   *          ┌──┐             │  │\n   *        ┗━│━━│━┛         ┗━└━━┘━┛\n   *          └──┘\n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          ┌──┐\n   *          │  │\n   *          │  │             ┌──┐\n   *        ┏━│━━│━┓         ┏━│━━│━┓\n   *          │  │             │  │\n   *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n   *                           │  │\n   *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───────────┐           ┌───────────┐\n   *  │     ┃     │   ┃       │ ┃         ┃\n   *  └───────────┘           └───────────┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *                ┌───┐             ┌───┐\n   *        ┃       │ ┃ │       ┃     │   ┃\n   *                └───┘             └───┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   */\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return 3 /* ScrollAlignment.RightOrBottom */;\n  }\n\n  return null;\n};\nconst canOverflow = overflow => {\n  return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = element => {\n  var _a;\n  try {\n    return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n  } catch (_b) {\n    return null;\n  }\n};\nconst isScrollable = (element, computedStyle) => {\n  if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n    return canOverflow(computedStyle.overflowY) || canOverflow(computedStyle.overflowX) || element === scrollingElement(element);\n  }\n  return false;\n};\nconst parentElement = element => {\n  const pNode = element.parentNode;\n  const pElement = element.parentElement;\n  if (pElement === null && pNode !== null) {\n    if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */11) {\n      return pNode.host;\n    }\n    if (pNode.nodeType === /** Node.DOCUMENT_NODE */9) {\n      return getFrameElement(element);\n    }\n  }\n  return pElement;\n};\nconst clamp = (value, min, max) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\nconst getSupportedScrollMarginProperty = ownerDocument => {\n  // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n  return [\"scroll-margin\", \"scroll-snap-margin\"].filter(property => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = elementRect;\n  const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n  if (!scrollProperty) {\n    return [top, right, bottom, left];\n  }\n  const scrollMarginValue = edge => {\n    const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n    return parseInt(value, 10) || 0;\n  };\n  return [top - scrollMarginValue(\"top\"), right + scrollMarginValue(\"right\"), bottom + scrollMarginValue(\"bottom\"), left - scrollMarginValue(\"left\")];\n};\nconst calcAlignEdge = (align, start, end) => {\n  switch (align) {\n    case 1 /* ScrollAlignment.CenterAlways */:\n      return (start + end) / 2;\n    case 3 /* ScrollAlignment.RightOrBottom */:\n      return end;\n    case 2 /* ScrollAlignment.LeftOrTop */:\n    case 0 /* ScrollAlignment.ToEdgeIfNeeded */:\n      return start;\n  }\n};\nconst getFrameViewport = (frame, frameRect) => {\n  var _a, _b, _c;\n  const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n  const [x, y, width, height] = frame === scrollingElement(frame) ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight] : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n  const left = x + frame.clientLeft;\n  const top = y + frame.clientTop;\n  const right = left + width;\n  const bottom = top + height;\n  return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const actions = [];\n  let ownerDocument = element.ownerDocument;\n  let ownerWindow = ownerDocument.defaultView;\n  if (!ownerWindow) {\n    return actions;\n  }\n  const computedStyle = window.getComputedStyle(element);\n  const isLTR = computedStyle.direction !== \"rtl\";\n  const writingMode = normalizeWritingMode(computedStyle.writingMode || computedStyle.getPropertyValue(\"-webkit-writing-mode\") || computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n  const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n  let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n  for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n    if (ownerDocument !== frame.ownerDocument) {\n      ownerDocument = frame.ownerDocument;\n      ownerWindow = ownerDocument.defaultView;\n      if (!ownerWindow) {\n        break;\n      }\n      const {\n        left: dX,\n        top: dY\n      } = frame.getBoundingClientRect();\n      top += dY;\n      right += dX;\n      bottom += dY;\n      left += dX;\n    }\n    const frameStyle = ownerWindow.getComputedStyle(frame);\n    if (frameStyle.position === \"fixed\") {\n      break;\n    }\n    if (!isScrollable(frame, frameStyle)) {\n      continue;\n    }\n    const frameRect = frame.getBoundingClientRect();\n    const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n    const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n    const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n    const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n    const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n    const moveX = isXReversed(frameStyle) ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft) : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n    const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n    actions.push([frame, {\n      left: frame.scrollLeft + moveX,\n      top: frame.scrollTop + moveY,\n      behavior: options.behavior\n    }]);\n    top = Math.max(top - moveY, frameTop);\n    right = Math.min(right - moveX, frameRight);\n    bottom = Math.min(bottom - moveY, frameBottom);\n    left = Math.max(left - moveX, frameLeft);\n  }\n  return actions;\n};\nexport const scrollIntoView = (element, scrollIntoViewOptions, config) => {\n  const options = scrollIntoViewOptions || {};\n  if (!checkBehavior(options.behavior)) {\n    throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n  }\n  const actions = computeScrollIntoView(element, options);\n  actions.forEach(_ref => {\n    let [frame, scrollToOptions] = _ref;\n    elementScroll(frame, scrollToOptions, config);\n  });\n};\nexport const elementScrollIntoView = scrollIntoView;","map":{"version":3,"mappings":"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","names":["checkBehavior","failedExecuteInvalidEnumValue","scrollingElement","elementScroll","normalizeWritingMode","writingMode","calcPhysicalAxis","isLTR","hPos","vPos","layout","isXReversed","computedStyle","direction","undefined","toPhysicalAlignment","options","block","inline","map","value","index","reverse","mapNearest","align","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","elementEdgeStart","elementEdgeEnd","elementSize","canOverflow","overflow","getFrameElement","element","ownerDocument","defaultView","frameElement","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","parentElement","pNode","parentNode","pElement","nodeType","host","clamp","min","max","getSupportedScrollMarginProperty","filter","property","documentElement","style","getElementScrollSnapArea","elementRect","top","right","bottom","left","scrollProperty","scrollMarginValue","edge","getPropertyValue","parseInt","calcAlignEdge","start","end","getFrameViewport","frame","frameRect","visualViewport","x","y","width","height","clientLeft","clientTop","computeScrollIntoView","actions","ownerWindow","window","getComputedStyle","alignH","alignV","getBoundingClientRect","dX","dY","frameStyle","position","frameTop","frameRight","frameBottom","frameLeft","eAlignH","eAlignV","diffX","diffY","moveX","scrollLeft","moveY","scrollTop","push","behavior","Math","scrollIntoView","scrollIntoViewOptions","config","TypeError","forEach","scrollToOptions","elementScrollIntoView"],"sources":["/Users/yiningmao/Desktop/DreamVideo/my-app/node_modules/seamless-scroll-polyfill/src/scrollIntoView.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step\";\nimport { elementScroll } from \"./scroll.js\";\n\nconst enum ScrollAlignment {\n    ToEdgeIfNeeded,\n    CenterAlways,\n    LeftOrTop,\n    RightOrBottom,\n}\n\nconst enum WritingMode {\n    HorizontalTb,\n    VerticalRl,\n    VerticalLr,\n    SidewaysRl,\n    SidewaysLr,\n}\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode: string): WritingMode => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return WritingMode.HorizontalTb;\n\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return WritingMode.VerticalRl;\n\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return WritingMode.VerticalLr;\n\n        case \"sideways-rl\":\n            return WritingMode.SidewaysRl;\n\n        case \"sideways-lr\":\n            return WritingMode.SidewaysLr;\n    }\n\n    return WritingMode.HorizontalTb;\n};\n\ntype Tuple2<T> = [T, T];\n\nconst calcPhysicalAxis = <T>(writingMode: WritingMode, isLTR: boolean, hPos: T, vPos: T): [number, T, T] => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n\n    const enum OP {\n        ReverseHorizontal = 0b01,\n        ReverseVertical = 0b10,\n    }\n\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= OP.ReverseVertical;\n    }\n\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case WritingMode.HorizontalTb:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case WritingMode.VerticalRl:\n        case WritingMode.SidewaysRl:\n            //  reverse horizontal\n            layout ^= OP.ReverseHorizontal;\n            break;\n\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case WritingMode.SidewaysLr:\n            // reverse vertical\n            layout ^= OP.ReverseVertical;\n            break;\n    }\n\n    return [layout, hPos, vPos];\n};\n\nconst isXReversed = (computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    const layout = calcPhysicalAxis(\n        normalizeWritingMode(computedStyle.writingMode),\n        computedStyle.direction !== \"rtl\",\n        undefined,\n        undefined,\n    )[0];\n    return (layout & 1) === 1;\n};\n\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (\n    options: Readonly<ScrollIntoViewOptions>,\n    writingMode: WritingMode,\n    isLTR: boolean,\n): Tuple2<ScrollAlignment> => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(\n        writingMode,\n        isLTR,\n        options.block || \"start\",\n        options.inline || \"nearest\",\n    );\n\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return ScrollAlignment.CenterAlways;\n            case \"nearest\":\n                return ScrollAlignment.ToEdgeIfNeeded;\n\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? ScrollAlignment.LeftOrTop : ScrollAlignment.RightOrBottom;\n            }\n        }\n    }) as Tuple2<ScrollAlignment>;\n};\n\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (\n    align: ScrollAlignment,\n    scrollingEdgeStart: number,\n    scrollingEdgeEnd: number,\n    scrollingSize: number,\n    elementEdgeStart: number,\n    elementEdgeEnd: number,\n    elementSize: number,\n): Exclude<ScrollAlignment, ScrollAlignment.ToEdgeIfNeeded> | null => {\n    if (align !== ScrollAlignment.ToEdgeIfNeeded) {\n        return align;\n    }\n\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n    ) {\n        return null;\n    }\n\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n    ) {\n        return ScrollAlignment.LeftOrTop;\n    }\n\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if (\n        (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n    ) {\n        return ScrollAlignment.RightOrBottom;\n    }\n\n    return null;\n};\n\nconst canOverflow = (overflow: string | null): boolean => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = (element: Element): Element | null => {\n    try {\n        return element.ownerDocument.defaultView?.frameElement || null;\n    } catch {\n        return null;\n    }\n};\n\nconst isScrollable = (element: Element, computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (\n            canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element)\n        );\n    }\n\n    return false;\n};\n\nconst parentElement = (element: Element): Element | null => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return (pNode as ShadowRoot).host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n\n    return pElement;\n};\n\nconst clamp = (value: number, min: number, max: number): number => {\n    if (value < min) {\n        return min;\n    }\n\n    if (value > max) {\n        return max;\n    }\n\n    return value;\n};\n\nconst getSupportedScrollMarginProperty = (\n    ownerDocument: Document,\n): \"scroll-margin\" | \"scroll-snap-margin\" | undefined => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ([\"scroll-margin\", \"scroll-snap-margin\"] as const).filter(\n        (property) => property in ownerDocument.documentElement.style,\n    )[0];\n};\n\nconst getElementScrollSnapArea = (\n    element: Element,\n    elementRect: Readonly<DOMRect>,\n    computedStyle: Readonly<CSSStyleDeclaration>,\n): [top: number, right: number, bottom: number, left: number] => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n\n    const scrollMarginValue = (edge: \"top\" | \"right\" | \"bottom\" | \"left\"): number => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\n\nconst calcAlignEdge = (align: ScrollAlignment, start: number, end: number): number => {\n    switch (align) {\n        case ScrollAlignment.CenterAlways:\n            return (start + end) / 2;\n\n        case ScrollAlignment.RightOrBottom:\n            return end;\n\n        case ScrollAlignment.LeftOrTop:\n        case ScrollAlignment.ToEdgeIfNeeded:\n            return start;\n    }\n};\n\nconst getFrameViewport = (frame: Element, frameRect: Readonly<DOMRect>) => {\n    const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n    const [x, y, width, height] =\n        frame === scrollingElement(frame)\n            ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight]\n            : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n\n    return [top, right, bottom, left] as const;\n};\n\nconst computeScrollIntoView = (element: Element, options: ScrollIntoViewOptions): [Element, ScrollToOptions][] => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions: [Element, ScrollToOptions][] = [];\n\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n\n    if (!ownerWindow) {\n        return actions;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n\n    const writingMode = normalizeWritingMode(\n        computedStyle.writingMode ||\n            computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n            computedStyle.getPropertyValue(\"-ms-writing-mode\"),\n    );\n\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n\n        const frameRect = frame.getBoundingClientRect();\n\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n\n        const diffX =\n            eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY =\n            eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n\n    return actions;\n};\n\nexport const scrollIntoView = (\n    element: Element,\n    scrollIntoViewOptions?: ScrollIntoViewOptions,\n    config?: IScrollConfig,\n): void => {\n    const options = scrollIntoViewOptions || {};\n\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n\n    const actions = computeScrollIntoView(element, options);\n\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\n\nexport const elementScrollIntoView = scrollIntoView;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}